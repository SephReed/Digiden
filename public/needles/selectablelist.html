<style>
	*[selectableItem] {
		cursor: pointer;
	}
</style>


<script>

// var man_selectableList_vars = {
// 	"selectOnHover" : {
// 		"default" : "false",
// 		"overview" : "make selection happen on hover, like in a suggestion bar",
// 		"true" : "items will be selected on hover",
// 		"false" : "items will not be selected on hover",
// 	}
// }



var man_selectableList_fns = {};
// var man_selectableList_fns = {
// 	"overview" : "the range is (-1, last position) where -1 means no selection",

// 	

// 	"getSelected()" : {
// 		"overview" : "move the selection to a set index",
// 		"return" : "(domNode) the element which is currently selected, or undefined"
// 	},

// }


// PINE.man("[selectableList]", "")



var p_selectableList = PINE.Needle("[selectableList]");
p_selectableList.addFunction(function(initMe) {

	var selectables;
	var currentlySelected = [];
	var currentIndex = 0;

	var selectOn_att = El.attr(initMe, "selectOn");
	var selectOnHover = selectOn_att ? selectOn_att.indexOf("hover") != -1 : false;
	var selectOnClick = selectOn_att ? selectOn_att.indexOf("click") != -1 : true;
	if(selectOnHover) {
		initMe.addEventListener("mouseleave", function() {
			initMe.FNS.setSelected(-1);
		});
	}

	if(selectOnClick) {
		initMe.addEventListener("blur", function() {
			initMe.FNS.setSelected(-1);
		});
	}


	var selectableLimit_att = El.attr(initMe, "selectableLimit");
	var selectableLimit = 1;
	if(selectableLimit_att != undefined) {
		if(selectableLimit_att == "none")
			selectableLimit = -1;
		else
			selectableLimit = parseInt(selectableLimit_att);
	}



	var selectionSwitch_att = El.attr(initMe, "selectionSwitch");
	var selectionSwitch = selectionSwitch_att || "always";
	//"never", "always", "shift_ctrl"




	


	El.attr(initMe, "tabIndex", "0");
	initMe.addEventListener("keyup", function(event) {
		console.log("keypressed")
		initMe.FNS.keypress(event.key);
	});


	var lastMouseSelection;
	PINE.addFunctionToNode(initMe, "keypress", function(key) {
		if(key == "ArrowUp") 
			initMe.FNS.moveSelection(-1);

		else if(key == "ArrowDown") 
			initMe.FNS.moveSelection(1);
	});


	PINE.addFunctionToNode(initMe, "refresh", function() {
		//get all new selectable items
		selectables = initMe.querySelectorAll("*[selectableItem]");
		console.log("selectables");
		console.log(selectables);

		//then check for one that's already selected.  make sure there's only one
		if(selectables.length > 0) {
			currentIndex = -1;
				//
			for(var i = 0; i < selectables.length; i++) {

				if(El.attr(selectables[i], "selected") != undefined) {
					if(currentIndex == -1) 
						currentIndex = i;

					if(currentlySelected < selectableLimit)
						currentlySelected.push(selectables[i]);
					
					else 
						selectables[i].removeAttribute("selected");
				}

				if(selectOnHover || selectOnClick) {
					var lastTarget;
					var onHover = function(index) {
						return function(event) {
							var hover_fulfilled = selectOnHover && lastTarget == initMe;
							var click_fulfilled = selectOnClick && event.buttons == 1;

							if(hover_fulfilled || click_fulfilled)
								initMe.FNS.setSelected(index, true);	

							lastTarget = initMe;
						}
					}(i)
					selectables[i].addEventListener("mousemove", onHover);
				}

				if (selectOnClick) {
					var onClick = function(index) {
						return function(event) {
							initMe.FNS.setSelected(index);	
						}
					}(i)
					selectables[i].addEventListener("click", onClick);
				}
			}
		}

	});



	man_selectableList_fns["moveSelection"] = {
		overview : "move the selection forwards or backwards",
		call : "moveSelection(int num_spaces)",
		num_spaces : "(int) the amount the selection will move.",
	}
	PINE.addFunctionToNode(initMe, "moveSelection", function(spaces) {
		initMe.FNS.setSelected(currentIndex + spaces);
	});



	man_selectableList_fns["setSelected"] = {
		overview : "move the selection to a set index",
		call : "setSelected(int index)",
		index : "(int) the position to which the selection will be moved."
	}
	PINE.addFunctionToNode(initMe, "setSelected", function(index, selectionValue) {
		if(selectables.length > 0 && selectableLimit != 0) {
			index = Math.max(-1, index);
			index = Math.min(selectables.length-1, index);

			// if(index != currentIndex) {
				currentIndex = index;

				if(currentIndex == -1) {
					for(var i in currentlySelected) 
						currentlySelected[i].removeAttribute("selected");
					currentlySelected = [];
				}
				else {
					var mostRecentlySelected = selectables[currentIndex];
					var indexInSelections = currentlySelected.indexOf(mostRecentlySelected);
					if(indexInSelections == -1) {
						if(selectableLimit != -1 && currentlySelected.length >= selectableLimit) {
							var shiftedOut = currentlySelected.shift();
							shiftedOut.removeAttribute("selected");
						}

						currentlySelected.push(mostRecentlySelected);

						var scroll_bottom = initMe.scrollTop + initMe.offsetHeight;
						var item_bottom = mostRecentlySelected.offsetTop + mostRecentlySelected.offsetHeight - initMe.offsetTop;
					
						if(scroll_bottom < item_bottom)
							initMe.scrollTop = item_bottom - initMe.offsetHeight;

						var item_top = mostRecentlySelected.offsetTop - initMe.offsetTop;					
						if(initMe.scrollTop > item_top)
							initMe.scrollTop = item_top;

						El.attr(mostRecentlySelected, "selected", "");
					}
					else if (selectionSwitch == "always" && selectionValue != true) {
						currentlySelected.splice(indexInSelections, 1);
						mostRecentlySelected.removeAttribute("selected");
					}
				}

			// }
		}
	});


	PINE.addFunctionToNode(initMe, "getSelected", function() {
		return currentlySelected;
	});

});

PINE.Needle("[selectableList]").addFunction({
	opType: PINE.ops.COMMON,
	isMultirun : true,
	fn: function(initMe) {
		initMe.FNS.refresh();
	}
});
</script>